{\rtf1\ansi\ansicpg936\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red100\green56\blue32;\red196\green26\blue22;
\red170\green13\blue145;\red28\green0\blue207;\red92\green38\blue153;\red14\green14\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab692
\pard\tx692\pardeftab692\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \CocoaLigature0 /*	NSURLSession.h\
	Copyright (c) 2013-2016, Apple Inc. All rights reserved.\
*/\cf0 \
\
\cf3 #import \cf4 <Foundation/NSObject.h>\cf3 \
#import \cf4 <Foundation/NSURLRequest.h>\cf3 \
#import \cf4 <Foundation/NSHTTPCookieStorage.h>\cf3 \
\cf0 \
\cf3 #include \cf4 <Security/SecureTransport.h>\cf3 \
\cf0 \
\cf5 @class\cf0  NSString;\
\cf5 @class\cf0  NSURL;\
\cf5 @class\cf0  NSError;\
\cf5 @class\cf0  NSArray<ObjectType>;\
\cf5 @class\cf0  NSDictionary<KeyType, ObjectType>;\
\cf5 @class\cf0  NSInputStream;\
\cf5 @class\cf0  NSOutputStream;\
\cf5 @class\cf0  NSData;\
\cf5 @class\cf0  NSOperationQueue;\
\
\cf5 @class\cf0  NSURLCache;\
\cf5 @class\cf0  NSURLResponse;\
\cf5 @class\cf0  NSHTTPURLResponse;\
\cf5 @class\cf0  NSHTTPCookie;\
\cf5 @class\cf0  NSCachedURLResponse;\
\cf5 @class\cf0  NSURLAuthenticationChallenge;\
\cf5 @class\cf0  NSURLProtectionSpace;\
\cf5 @class\cf0  NSURLCredential;\
\cf5 @class\cf0  NSURLCredentialStorage;\
\cf5 @class\cf0  NSURLSessionDataTask;\
\cf5 @class\cf0  NSURLSessionUploadTask;\
\cf5 @class\cf0  NSURLSessionDownloadTask;\
\cf5 @class\cf0  NSNetService;\
\
\cf2 /*\
 NSURLSession
\f1 \'ca\'c7
\f0 NSURLConnection
\f1 \'b5\'c4\'cc\'e6\'b4\'fa
\f0 API
\f1 \'a1\'a3
\f0 \

\f1  \'cb\'fc\'cc\'e1\'b9\'a9\'c1\'cb\'d3\'b0\'cf\'ec
\f0 NSURLRequest
\f1 \'b6\'d4\'cf\'f3\'b4\'d3\'cd\'f8\'c2\'e7\'bc\'ec\'cb\'f7\'b5\'c4\'bb\'fa\'d6\'c6\'b5\'c4\'b2\'df\'c2\'d4\'ba\'cd\'b8\'f7\'d6\'d6\'b7\'bd\'c3\'e6\'b5\'c4\'d1\'a1\'cf\'ee\'a1\'a3
\f0 \
\
\'a0NSURLSession
\f1 \'bf\'c9\'d2\'d4\'b0\'f3\'b6\'a8\'b5\'bd\'ce\'af\'cd\'d0\'b6\'d4\'cf\'f3\'a1\'a3\'d4\'da\'bb\'e1\'bb\'b0\'b5\'c4\'c9\'fa\'c3\'fc\'d6\'dc\'c6\'da\'c6\'da\'bc\'e4\'d5\'eb\'b6\'d4\'c4\'b3\'d0\'a9\'ca\'c2\'bc\'fe\'b5\'f7\'d3\'c3\'ce\'af\'cd\'d0\'a3\'ac\'c0\'fd\'c8\'e7\'b7\'fe\'ce\'f1\'c6\'f7\'c8\'cf\'d6\'a4\'bb\'f2\'c8\'b7\'b6\'a8\'ca\'c7\'b7\'f1\'d3\'a6\'bd\'ab\'d2\'aa\'bc\'d3\'d4\'d8\'b5\'c4\'d7\'ca\'d4\'b4\'d7\'aa\'bb\'bb\'ce\'aa\'cf\'c2\'d4\'d8\'a1\'a3
\f0 \
\'a0\
\'a0NSURLSession
\f1 \'ca\'b5\'c0\'fd\'ca\'c7\'cf\'df\'b3\'cc\'b0\'b2\'c8\'ab\'b5\'c4\'a1\'a3
\f0 \
\
\'a0
\f1 \'c4\'ac\'c8\'cf\'b5\'c4
\f0 NSURLSession
\f1 \'ca\'b9\'d3\'c3\'cf\'b5\'cd\'b3\'cc\'e1\'b9\'a9\'b5\'c4\'b4\'fa\'c0\'ed\'a3\'ac\'b2\'a2\'ca\'ca\'ba\'cf\'ca\'b9\'d3\'c3\'b4\'fa\'cc\'e6\'cf\'d6\'d3\'d0\'b4\'fa\'c2\'eb\'ca\'b9\'d3\'c3
\f0 \
\'a0+[NSURLConnection sendAsynchronousRequest:queue:completionHandler:]\
\
\'a0NSURLSession
\f1 \'b4\'b4\'bd\'a8
\f0 NSURLSessionTask
\f1 \'b6\'d4\'cf\'f3\'a3\'ac\'d5\'e2\'d0\'a9\'b6\'d4\'cf\'f3\'b1\'ed\'ca\'be\'d5\'fd\'d4\'da\'bc\'d3\'d4\'d8\'b5\'c4\'d7\'ca\'d4\'b4\'b5\'c4\'b2\'d9\'d7\'f7\'a1\'a3\'d5\'e2\'d0\'a9\'c0\'e0\'cb\'c6\'d3\'da
\f0 NSURLConnection
\f1 \'b6\'d4\'cf\'f3\'a3\'ac\'b5\'ab\'cc\'e1\'b9\'a9\'b8\'fc\'b6\'e0\'b5\'c4\'bf\'d8\'d6\'c6\'ba\'cd\'cd\'b3\'d2\'bb\'b5\'c4\'ce\'af\'cd\'d0\'c4\'a3\'d0\'cd\'a1\'a3
\f0 \
\'a0\
\'a0NSURLSessionTask
\f1 \'b6\'d4\'cf\'f3\'ca\'bc\'d6\'d5\'d2\'d4\'d4\'dd\'cd\'a3\'d7\'b4\'cc\'ac\'b4\'b4\'bd\'a8\'a3\'ac\'b2\'a2\'c7\'d2\'b1\'d8\'d0\'eb\'d4\'da\'d6\'b4\'d0\'d0\'d6\'ae\'c7\'b0\'b7\'a2\'cb\'cd
\f0 -resume
\f1 \'cf\'fb\'cf\'a2\'a1\'a3
\f0 \
\
\'a0NSURLSessionTask
\f1 \'b5\'c4\'d7\'d3\'c0\'e0\'d3\'c3\'d3\'da\'d4\'da\'d3\'ef\'b7\'a8\'c9\'cf\'c7\'f8\'b7\'d6\'ca\'fd\'be\'dd\'ba\'cd\'ce\'c4\'bc\'fe\'cf\'c2\'d4\'d8\'a1\'a3
\f0 \
\
\'a0NSURLSessionDataTask
\f1 \'bd\'d3\'ca\'d5\'d7\'ca\'d4\'b4\'d7\'f7\'ce\'aa\'b6\'d4
\f0 URLSession
\f1 \'b5\'c4\'d2\'bb\'cf\'b5\'c1\'d0\'b5\'f7\'d3\'c3 
\f0 URLSession:dataTask:didReceiveData: delegate
\f1 \'b7\'bd\'b7\'a8\'a1\'a3\
  \'d5\'e2\'ca\'c7\'d7\'ee\'b3\'a3\'d3\'eb\'bc\'ec\'cb\'f7\'b6\'d4\'cf\'f3\'d2\'d4\'b9\'a9\'cf\'fb\'b7\'d1\'d5\'df\'c1\'a2\'bc\'b4\'bd\'e2\'ce\'f6\'cf\'e0\'b9\'d8\'c1\'aa\'b5\'c4\'c8\'ce\'ce\'f1\'c0\'e0\'d0\'cd\'a1\'a3
\f0 \
\
\'a0NSURLSessionUploadTask
\f1 \'d3\'eb
\f0 NSURLSessionDataTask
\f1 \'d4\'da\'c6\'e4\'ca\'b5\'c0\'fd\'b5\'c4\'b9\'b9\'d4\'ec\'b7\'bd\'ca\'bd\'c9\'cf\'b2\'bb\'cd\'ac\'a1\'a3\
  \'c9\'cf\'b4\'ab\'c8\'ce\'ce\'f1\'ca\'c7\'cd\'a8\'b9\'fd\'d2\'fd\'d3\'c3\'d2\'aa\'c9\'cf\'b4\'ab\'b5\'c4\'ce\'c4\'bc\'fe\'bb\'f2\'ca\'fd\'be\'dd\'b6\'d4\'cf\'f3\'c0\'b4\'cf\'d4\'ca\'bd\'b4\'b4\'bd\'a8\'b5\'c4,\
  \'bb\'f2\'d5\'df\'cd\'a8\'b9\'fd\'ca\'b9\'d3\'c3 
\f0 -URLSession:task:needNewBodyStream: delegate 
\f1 \'cf\'fb\'cf\'a2\'c0\'b4\'cc\'e1\'b9\'a9\'c9\'cf\'b4\'ab\'d5\'fd\'ce\'c4\'a1\'a3
\f0 \
\
\'a0NSURLSessionDownloadTask
\f1 \'bd\'ab\'d6\'b1\'bd\'d3\'bd\'ab\'cf\'ec\'d3\'a6\'ca\'fd\'be\'dd\'d0\'b4\'c8\'eb\'c1\'d9\'ca\'b1\'ce\'c4\'bc\'fe\'a1\'a3\
  \'cd\'ea\'b3\'c9\'ba\'f3\'a3\'ac\'bb\'e1\'cf\'f2\'b4\'fa\'c0\'ed\'b7\'a2\'cb\'cd 
\f0 URLSession:downloadTask:didFinishDownloadingToURL: 
\f1 \'b2\'a2\'b8\'f8\'d3\'e8\'bb\'fa\'bb\'e1\'bd\'ab\'b4\'cb\'ce\'c4\'bc\'fe\'d2\'c6\'b6\'af\'b5\'bd\'c6\'e4\'c9\'b3\'ba\'d0\'c8\'dd\'c6\'f7\'d6\'d0\'b5\'c4\'d3\'c0\'be\'c3\'ce\'bb\'d6\'c3\'a3\'ac\'bb\'f2\'d2\'d4\'c6\'e4\'cb\'fb\'b7\'bd\'ca\'bd\'b6\'c1\'c8\'a1\'ce\'c4\'bc\'fe\'a1\'a3\
  \'c8\'e7\'b9\'fb\'c8\'a1\'cf\'fb\'a3\'ac
\f0 NSURLSessionDownloadTask
\f1 \'bf\'c9\'d2\'d4\'b2\'fa\'c9\'fa\'d2\'bb\'b8\'f6\'ca\'fd\'be\'dd
\f0 blob
\f1 \'a3\'ac\'bf\'c9\'d3\'c3\'d3\'da\'d2\'d4\'ba\'f3\'bb\'d6\'b8\'b4\'cf\'c2\'d4\'d8\'a1\'a3
\f0 \
\
 
\f1 \'b4\'d3
\f0 iOS 9
\f1 \'ba\'cd
\f0 Mac OS X 10.11
\f1 \'bf\'aa\'ca\'bc\'a3\'ac
\f0 NSURLSessionStream
\f1 \'bf\'c9\'d3\'c3\'d7\'f7\'c8\'ce\'ce\'f1\'c0\'e0\'d0\'cd\'a1\'a3\
  \'d5\'e2\'d4\'ca\'d0\'ed\'b5\'bd\'b8\'f8\'b6\'a8\'d6\'f7\'bb\'fa\'ba\'cd\'b6\'cb\'bf\'da\'b5\'c4\'d6\'b1\'bd\'d3
\f0 TCP / IP
\f1 \'c1\'ac\'bd\'d3\'a3\'ac\'be\'df\'d3\'d0\'bf\'c9\'d1\'a1\'b5\'c4\'b0\'b2\'c8\'ab\'ce\'d5\'ca\'d6\'ba\'cd\'b4\'fa\'c0\'ed\'b5\'bc\'ba\'bd\'a1\'a3\
  \'ca\'fd\'be\'dd\'c8\'ce\'ce\'f1\'d2\'b2\'bf\'c9\'d2\'d4\'cd\'a8\'b9\'fd
\f0 HTTP
\f1 \'c9\'fd\'bc\'b6:\'cd\'b7\'b2\'bf\'ba\'cd\'ca\'ca\'b5\'b1\'ca\'b9\'d3\'c3
\f0 NSURLSessionConfiguration
\f1 \'b5\'c4\'c1\'f7\'cb\'ae\'cf\'df\'d1\'a1\'cf\'ee\'c9\'fd\'bc\'b6\'b5\'bd
\f0 NSURLSessionStream
\f1 \'c8\'ce\'ce\'f1\'a1\'a3\
  \'d3\'d0\'b9\'d8
\f0 Upgrade
\f1 \'a3\'ba\'b1\'ea\'cc\'e2\'b5\'c4\'d0\'c5\'cf\'a2\'a3\'ac\'d2\'d4\'bc\'b0\'d3\'d0\'b9\'d8\'bd\'ab\'ca\'fd\'be\'dd\'c8\'ce\'ce\'f1\'d7\'aa  \'bb\'bb\'ce\'aa\'c1\'f7\'c8\'ce\'ce\'f1\'b5\'c4\'d7\'a2\'ca\'cd\'a3\'ac\'c7\'eb\'b2\'ce\'d4\'c4
\f0 RFC 2817
\f1 \'ba\'cd
\f0 RFC 6455
\f1 \'a1\'a3
\f0  \
 */\cf0 \
\
\cf5 @class\cf0  NSURLSession;\
\cf5 @class\cf0  NSURLSessionDataTask;                \cf2 /* DataTask
\f1 \'b6\'d4\'cf\'f3\'cd\'a8\'b9\'fd\'c1\'e3\'b8\'f6\'bb\'f2\'b6\'e0\'b8\'f6\'ce\'af\'cd\'d0\'cf\'fb\'cf\'a2\'bd\'d3\'ca\'d5\'d3\'d0\'d0\'a7\'b8\'ba\'d4\'d8
\f0  */\cf0 \
\cf5 @class\cf0  NSURLSessionUploadTask;              \cf2 /* UploadTask
\f1 \'b6\'d4\'cf\'f3\'bd\'d3\'ca\'d5\'b6\'a8\'c6\'da\'b5\'c4\'bd\'f8\'b6\'c8\'b8\'fc\'d0\'c2\'a3\'ac\'b5\'ab\'b2\'bb\'b7\'b5\'bb\'d8\'d5\'fd\'ce\'c4
\f0  */\cf0 \
\cf5 @class\cf0  NSURLSessionDownloadTask;            \cf2 /* DownloadTask
\f1 \'b6\'d4\'cf\'f3\'b1\'ed\'ca\'be\'bb\'ee\'b6\'af\'cf\'c2\'d4\'d8\'b5\'bd\'b4\'c5\'c5\'cc
\f0 . 
\f1 \'c8\'a1\'cf\'fb\'ca\'b1\'bf\'c9\'d2\'d4\'cc\'e1\'b9\'a9\'bb\'d6\'b8\'b4\'ca\'fd\'be\'dd
\f0 . */\cf0 \
\cf5 @class\cf0  NSURLSessionStreamTask;              \cf2 /* StreamTask
\f1 \'b6\'d4\'cf\'f3\'bf\'c9\'d3\'c3\'d3\'da\'b4\'b4\'bd\'a8
\f0 NSInput
\f1 \'ba\'cd
\f0 NSOutputStream
\f1 \'a3\'ac\'bb\'f2\'d6\'b1\'bd\'d3\'d3\'c3\'d3\'da\'b6\'c1\'d0\'b4
\f0 . */\cf0 \
\cf5 @class\cf0  NSURLSessionConfiguration;\
\cf5 @protocol\cf0  NSURLSessionDelegate;\
\
\cf5 @class\cf0  NSURLSessionTaskMetrics;\
\cf5 @class\cf0  NSDateInterval;\
\
NS_ASSUME_NONNULL_BEGIN\
\
\cf2 /*\
\
 NSURLSession
\f1 \'b2\'bb\'ca\'ca\'d3\'c3\'d3\'da
\f0 MacOSX10.10 
\f1 \'d6\'ae\'c7\'b0\'b5\'c4 
\f0 i386
\f1 \'bf\'f2\'bc\'dc\'a1\'a3
\f0 \
\
 */\cf0 \
\
\cf3 #if __OBJC2__\
#define NSURLSESSION_AVAILABLE	\cf6 10\cf3 _9\
#else\
#define NSURLSESSION_AVAILABLE	\cf6 10\cf3 _10\
#endif\
\cf0 \
\
FOUNDATION_EXPORT \cf5 const\cf0  int64_t NSURLSessionTransferSizeUnknown NS_AVAILABLE(NSURLSESSION_AVAILABLE, \cf6 7\cf0 _0);    \cf2 /* -1LL */\cf0 \
\
NS_CLASS_AVAILABLE(NSURLSESSION_AVAILABLE, \cf6 7\cf0 _0)\
\cf5 @interface\cf0  NSURLSession : NSObject\
\
\cf2 /*\
 * 
\f1 \'b9\'b2\'cf\'ed\'bb\'e1\'bb\'b0\'ca\'b9\'d3\'c3\'b5\'b1\'c7\'b0\'c9\'e8\'d6\'c3\'b5\'c4\'c8\'ab\'be\'d6
\f0 NSURLCache'
\f1  
\f0 NSHTTPCookieStorage
\f1 \'ba\'cd
\f0 NSURLCredentialStorage
\f1 \'b6\'d4\'cf\'f3.
\f0 \
 */\cf0 \
\cf3 #if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(\cf6 8\cf3 )\
\cf5 @property\cf0  (\cf5 class\cf0 , \cf5 readonly\cf0 , \cf5 strong\cf0 ) NSURLSession *sharedSession;\
\cf3 #endif\
\cf0 \
\cf2 /*\
 * NSURLSession
\f1 \'b5\'c4\'b6\'a8\'d6\'c6\'d4\'da\'b4\'b4\'bd\'a8\'d0\'c2\'bb\'e1\'bb\'b0\'c6\'da\'bc\'e4
\f0 .\
 * 
\f1 \'c8\'e7\'b9\'fb\'c4\'e3\'d6\'bb\'d0\'e8\'d2\'aa\'ca\'b9\'d3\'c3\'d7\'d4\'b6\'a8\'d2\'e5\'b5\'c4\'c5\'e4\'d6\'c3\'d1\'a1\'cf\'ee\'b5\'c4\'b1\'e3\'c0\'fb\'b3\'cc\'d0\'f2\'a3\'ac\'c3\'bb\'d3\'d0\'b1\'d8\'d2\'aa\'d6\'b8\'b6\'a8\'d2\'bb\'b8\'f6\'ce\'af\'cd\'d0
\f0 .\
 * 
\f1 \'c8\'e7\'b9\'fb\'c4\'e3\'d6\'b8\'b6\'a8\'d2\'bb\'b8\'f6\'ce\'af\'cd\'d0\'a3\'ac\'ce\'af\'cd\'d0\'bd\'ab\'b1\'bb\'b1\'a3\'c1\'f4\'a3\'ac\'d6\'b1\'b5\'bd\'ce\'af\'cd\'d0\'b1\'bb\'b7\'a2\'cb\'cd
\f0 URLSession:didBecomeInvalidWithError: message.\
 */\cf0 \
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;\
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(\cf5 nullable\cf0  \cf5 id\cf0  <NSURLSessionDelegate>)delegate delegateQueue:(\cf5 nullable\cf0  NSOperationQueue *)queue;\
\
\cf5 @property\cf0  (\cf5 readonly\cf0 , \cf5 retain\cf0 ) NSOperationQueue *delegateQueue;\
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 retain\cf0 ) \cf5 id\cf0  <NSURLSessionDelegate> delegate;\
\cf5 @property\cf0  (\cf5 readonly\cf0 , \cf5 copy\cf0 ) NSURLSessionConfiguration *configuration;\
\
\cf2 /*\
 * sessionDescription
\f1 \'ca\'f4\'d0\'d4\'bf\'c9\'b9\'a9\'bf\'aa\'b7\'a2\'c8\'cb\'d4\'b1\'ce\'aa\'bb\'e1\'bb\'b0\'cc\'e1\'b9\'a9\'c3\'e8\'ca\'f6\'d0\'d4\'b1\'ea\'c7\'a9
\f0 .\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) NSString *sessionDescription;\
\
\cf2 /* -finishTasksAndInvalidate
\f1 \'c1\'a2\'bc\'b4\'b7\'b5\'bb\'d8\'a3\'ac\'cf\'d6\'d3\'d0\'c8\'ce\'ce\'f1\'bd\'ab\'d4\'ca\'d0\'ed\'d4\'cb\'d0\'d0\'b5\'bd\'cd\'ea\'b3\'c9\'a1\'a3
\f0  
\f1 \'bf\'c9\'c4\'dc\'b2\'bb\'bb\'e1\'b4\'b4\'bd\'a8\'d0\'c2\'c8\'ce\'ce\'f1\'a1\'a3
\f0  \
 *  
\f1 \'bb\'e1\'bb\'b0\'bd\'ab\'bc\'cc\'d0\'f8\'bd\'f8\'d0\'d0\'ce\'af\'cd\'d0\'bb\'d8\'b5\'f7\'a3\'ac\'d6\'b1\'b5\'bd
\f0 URLSession:didBecomeInvalidWithError:
\f1 \'d2\'d1\'d6\'b4\'d0\'d0
\f0 . \
 *\
 * -finishTasksAndInvalidate and -invalidateAndCancel 
\f1 \'b6\'d4\'b9\'b2\'cf\'ed\'bb\'e1\'bb\'b0\'b5\'a5\'c0\'fd\'c3\'bb\'d3\'d0\'c8\'ce\'ba\'ce\'d3\'b0\'cf\'ec
\f0 .\
 *\
 * 
\f1 \'b5\'b1\'ca\'b9\'ba\'f3\'cc\'a8\'bb\'e1\'bb\'b0\'ce\'de\'d0\'a7\'ca\'b1\'a3\'ac\'b4\'b4\'bd\'a8\'be\'df\'d3\'d0\'cf\'e0\'cd\'ac\'b1\'ea\'ca\'b6\'b7\'fb\'b5\'c4\'c1\'ed\'d2\'bb\'b8\'f6\'ba\'f3\'cc\'a8\'bb\'e1\'bb\'b0\'ca\'c7\'b2\'bb\'b0\'b2\'c8\'ab\'b5\'c4\'a3\'ac\'d6\'b1\'b5\'bd
\f0 URLSession
\f1 \'a3\'ba
\f0 didBecomeInvalidWithError
\f1 \'a3\'ba\'d2\'d1\'d6\'b4\'d0\'d0
\f0 .\
 */\cf0 \
- (\cf5 void\cf0 )finishTasksAndInvalidate;\
\
\cf2 /* -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues\
 * -cancel to all outstanding tasks for this session.  Note task \
 * cancellation is subject to the state of the task, and some tasks may\
 * have already have completed at the time they are sent -cancel. \
 */\cf0 \
- (\cf5 void\cf0 )invalidateAndCancel;\
\
- (\cf5 void\cf0 )resetWithCompletionHandler:(\cf5 void\cf0  (^)(\cf5 void\cf0 ))completionHandler;    \cf2 /* empty all cookies, cache and credential stores, removes disk files, issues -flushWithCompletionHandler:. Invokes completionHandler() on the delegate queue if not nil. */\cf0 \
- (\cf5 void\cf0 )flushWithCompletionHandler:(\cf5 void\cf0  (^)(\cf5 void\cf0 ))completionHandler;    \cf2 /* flush storage to disk and clear transient network caches.  Invokes completionHandler() on the delegate queue if not nil. */\cf0 \
\
- (\cf5 void\cf0 )getTasksWithCompletionHandler:(\cf5 void\cf0  (^)(NSArray<NSURLSessionDataTask *> *dataTasks, NSArray<NSURLSessionUploadTask *> *uploadTasks, NSArray<NSURLSessionDownloadTask *> *downloadTasks))completionHandler; \cf2 /* invokes completionHandler with outstanding data, upload and download tasks. */\cf0 \
\
- (\cf5 void\cf0 )getAllTasksWithCompletionHandler:(\cf5 void\cf0  (^)(NSArray<\cf5 __kindof\cf0  NSURLSessionTask *> *tasks))completionHandler NS_AVAILABLE(\cf6 10\cf0 _11, \cf6 9\cf0 _0); \cf2 /* invokes completionHandler with all outstanding tasks. */\cf0 \
\
\cf2 /* \
 * NSURLSessionTask objects are always created in a suspended state and\
 * must be sent the -resume message before they will execute.\
 */\cf0 \
\
\cf2 /* Creates a data task with the given request.  The request may have a body stream. */\cf0 \
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;\
\
\cf2 /* Creates a data task to retrieve the contents of the given URL. */\cf0 \
- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;\
\
\cf2 /* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */\cf0 \
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;\
\
\cf2 /* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */\cf0 \
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;\
\
\cf2 /* Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */\cf0 \
- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;\
\
\cf2 /* Creates a download task with the given request. */\cf0 \
- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;\
\
\cf2 /* Creates a download task to download the contents of the given URL. */\cf0 \
- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;\
\
\cf2 /* Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */\cf0 \
- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;\
\
\cf2 /* Creates a bidirectional stream task to a given host and port.\
 */\cf0 \
- (NSURLSessionStreamTask *)streamTaskWithHostName:(NSString *)hostname port:(NSInteger)port NS_AVAILABLE(\cf6 10\cf0 _11, \cf6 9\cf0 _0) __WATCHOS_PROHIBITED;\
\
\cf2 /* Creates a bidirectional stream task with an NSNetService to identify the endpoint.\
 * The NSNetService will be resolved before any IO completes.\
 */\cf0 \
- (NSURLSessionStreamTask *)streamTaskWithNetService:(NSNetService *)service NS_AVAILABLE(\cf6 10\cf0 _11, \cf6 9\cf0 _0) __WATCHOS_PROHIBITED;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * NSURLSession convenience routines deliver results to \
 * a completion handler block.  These convenience routines\
 * are not available to NSURLSessions that are configured\
 * as background sessions.\
 *\
 * Task objects are always created in a suspended state and \
 * must be sent the -resume message before they will execute.\
 */\cf0 \
\cf5 @interface\cf0  NSURLSession (NSURLSessionAsynchronousConvenience)\
\cf2 /*\
 * data task convenience methods.  These methods create tasks that\
 * bypass the normal delegate calls for response and data delivery,\
 * and provide a simple cancelable asynchronous interface to receiving\
 * data.  Errors will be returned in the NSURLErrorDomain, \
 * see <Foundation/NSURLError.h>.  The delegate, if any, will still be\
 * called for authentication challenges.\
 */\cf0 \
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(\cf5 void\cf0  (^)(NSData * \cf5 _Nullable\cf0  data, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(\cf5 void\cf0  (^)(NSData * \cf5 _Nullable\cf0  data, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
\
\cf2 /*\
 * upload convenience method.\
 */\cf0 \
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(\cf5 void\cf0  (^)(NSData * \cf5 _Nullable\cf0  data, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(\cf5 nullable\cf0  NSData *)bodyData completionHandler:(\cf5 void\cf0  (^)(NSData * \cf5 _Nullable\cf0  data, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
\
\cf2 /*\
 * download task convenience methods.  When a download successfully\
 * completes, the NSURL will point to a file that must be read or\
 * copied during the invocation of the completion routine.  The file\
 * will be removed automatically.\
 */\cf0 \
- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(\cf5 void\cf0  (^)(NSURL * \cf5 _Nullable\cf0  location, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(\cf5 void\cf0  (^)(NSURL * \cf5 _Nullable\cf0  location, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(\cf5 void\cf0  (^)(NSURL * \cf5 _Nullable\cf0  location, NSURLResponse * \cf5 _Nullable\cf0  response, NSError * \cf5 _Nullable\cf0  error))completionHandler;\
\
\cf5 @end\cf0 \
\
\
\cf5 typedef\cf0  \cf5 NS_ENUM\cf0 (NSInteger, NSURLSessionTaskState) \{\
    NSURLSessionTaskStateRunning = \cf6 0\cf0 ,                     \cf2 /* The task is currently being serviced by the session */\cf0 \
    NSURLSessionTaskStateSuspended = \cf6 1\cf0 ,\
    NSURLSessionTaskStateCanceling = \cf6 2\cf0 ,                   \cf2 /* The task has been told to cancel.  The session will receive a URLSession:task:didCompleteWithError: message. */\cf0 \
    NSURLSessionTaskStateCompleted = \cf6 3\cf0 ,                   \cf2 /* The task has completed and the session will receive no more delegate notifications */\cf0 \
\} NS_ENUM_AVAILABLE(NSURLSESSION_AVAILABLE, \cf6 7\cf0 _0);\
\
\cf2 /*\
 * NSURLSessionTask - a cancelable object that refers to the lifetime\
 * of processing a given request.\
 */\cf0 \
NS_CLASS_AVAILABLE(NSURLSESSION_AVAILABLE, \cf6 7\cf0 _0)\
\cf5 @interface\cf0  NSURLSessionTask : NSObject <NSCopying>\
\
\cf5 @property\cf0  (\cf5 readonly\cf0 )                 NSUInteger    taskIdentifier;    \cf2 /* an identifier for this task, assigned by and unique to the owning session */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 copy\cf0 ) NSURLRequest  *originalRequest;  \cf2 /* may be nil if this is a stream task */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 copy\cf0 ) NSURLRequest  *currentRequest;   \cf2 /* may differ from originalRequest due to http server redirection */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 copy\cf0 ) NSURLResponse *response;         \cf2 /* may be nil if no response has been received */\cf0 \
\
\cf2 /* Byte count properties may be zero if no body is expected, \
 * or NSURLSessionTransferSizeUnknown if it is not possible \
 * to know how many bytes will be transferred.\
 */\cf0 \
\
\cf2 /* 
\f1 \'d2\'d1\'bd\'d3\'ca\'d5\'b5\'c4\'d6\'f7\'cc\'e5\'d7\'d6\'bd\'da\'ca\'fd
\f0  */\cf0 \
\cf5 @property\cf0  (\cf5 readonly\cf0 ) int64_t countOfBytesReceived;\
\
\cf2 /* 
\f1 \'d2\'d1\'b7\'a2\'cb\'cd\'b5\'c4\'d6\'f7\'cc\'e5\'d7\'d6\'bd\'da\'ca\'fd
\f0  */\cf0 \
\cf5 @property\cf0  (\cf5 readonly\cf0 ) \cf7 int64_t\cf0  countOfBytesSent;\
\
\cf2 /* 
\f1 \'ce\'d2\'c3\'c7\'c6\'da\'cd\'fb\'b7\'a2\'cb\'cd\'b5\'c4\'d6\'f7\'cc\'e5\'d7\'d6\'bd\'da\'ca\'fd\'a3\'ac\'b4\'d3
\f0 HTTP
\f1 \'c7\'eb\'c7\'f3\'b5\'c4
\f0 Content-Length
\f1 \'c5\'c9\'c9\'fa
\f0  */\cf0 \
\cf5 @property\cf0  (\cf5 readonly\cf0 ) \cf7 int64_t\cf0  countOfBytesExpectedToSend;\
\
\cf2 /* 
\f1 \'ce\'d2\'c3\'c7\'c6\'da\'cd\'fb\'bd\'d3\'ca\'d5\'b5\'c4\'d7\'d6\'bd\'da\'d7\'d6\'bd\'da\'ca\'fd\'a3\'ac\'cd\'a8\'b3\'a3\'c0\'b4\'d7\'d4
\f0 HTTP
\f1 \'cf\'ec\'d3\'a6\'b5\'c4
\f0 Content-Length
\f1 \'cd\'b7
\f0 . */\cf0 \
\cf5 @property\cf0  (\cf5 readonly\cf0 ) \cf7 int64_t\cf0  countOfBytesExpectedToReceive;\
\
\cf2 /*\
 * The taskDescription property is available for the developer to\
 * provide a descriptive label for the task.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) \cf7 NSString\cf0  *taskDescription;\
\
\cf2 /* -cancel returns immediately, but marks a task as being canceled.\
 * The task will signal -URLSession:task:didCompleteWithError: with an\
 * error value of \{ NSURLErrorDomain, NSURLErrorCancelled \}.  In some \
 * cases, the task may signal other work before it acknowledges the \
 * cancelation.  -cancel may be sent to a task that has been suspended.\
 */\cf0 \
- (\cf5 void\cf0 )cancel;\
\
\cf2 /*\
 * The current state of the task within the session.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 readonly\cf0 ) \cf7 NSURLSessionTaskState\cf0  state;\
\
\cf2 /*\
 * The error, if any, delivered via -URLSession:task:didCompleteWithError:\
 * This property will be nil in the event that no error occured.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 copy\cf0 ) \cf7 NSError\cf0  *error;\
\
\cf2 /*\
 * Suspending a task will prevent the NSURLSession from continuing to\
 * load data.  There may still be delegate calls made on behalf of\
 * this task (for instance, to report data received while suspending)\
 * but no further transmissions will be made on behalf of the task\
 * until -resume is sent.  The timeout timer associated with the task\
 * will be disabled while a task is suspended. -suspend and -resume are\
 * nestable. \
 */\cf0 \
- (\cf5 void\cf0 )suspend;\
- (\cf5 void\cf0 )resume;\
\
\cf2 /*\
 * Sets a scaling factor for the priority of the task. The scaling factor is a\
 * value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest\
 * priority and 1.0 is considered the highest.\
 *\
 * The priority is a hint and not a hard requirement of task performance. The\
 * priority of a task may be changed using this API at any time, but not all\
 * protocols support this; in these cases, the last priority that took effect\
 * will be used.\
 *\
 * If no priority is specified, the task will operate with the default priority\
 * as defined by the constant NSURLSessionTaskPriorityDefault. Two additional\
 * priority levels are provided: NSURLSessionTaskPriorityLow and\
 * NSURLSessionTaskPriorityHigh, but use is not restricted to these.\
 */\cf0 \
\cf5 @property\cf0  \cf5 float\cf0  priority \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\
\cf5 @end\cf0 \
\
\cf3 FOUNDATION_EXPORT\cf0  \cf5 const\cf0  \cf5 float\cf0  NSURLSessionTaskPriorityDefault \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\cf3 FOUNDATION_EXPORT\cf0  \cf5 const\cf0  \cf5 float\cf0  NSURLSessionTaskPriorityLow \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\cf3 FOUNDATION_EXPORT\cf0  \cf5 const\cf0  \cf5 float\cf0  NSURLSessionTaskPriorityHigh \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\
\cf2 /*\
 * An NSURLSessionDataTask does not provide any additional\
 * functionality over an NSURLSessionTask and its presence is merely\
 * to provide lexical differentiation from download and upload tasks.\
 */\cf0 \
\cf5 @interface\cf0  NSURLSessionDataTask : \cf7 NSURLSessionTask\cf0 \
\cf5 @end\cf0 \
\
\cf2 /*\
 * An NSURLSessionUploadTask does not currently provide any additional\
 * functionality over an NSURLSessionDataTask.  All delegate messages\
 * that may be sent referencing an NSURLSessionDataTask equally apply\
 * to NSURLSessionUploadTasks.\
 */\cf0 \
\cf5 @interface\cf0  NSURLSessionUploadTask : \cf7 NSURLSessionDataTask\cf0 \
\cf5 @end\cf0 \
\
\cf2 /*\
 * NSURLSessionDownloadTask is a task that represents a download to\
 * local storage.\
 */\cf0 \
\cf5 @interface\cf0  NSURLSessionDownloadTask : \cf7 NSURLSessionTask\cf0 \
\
\cf2 /* Cancel the download (and calls the superclass -cancel).  If\
 * conditions will allow for resuming the download in the future, the\
 * callback will be called with an opaque data blob, which may be used\
 * with -downloadTaskWithResumeData: to attempt to resume the download.\
 * If resume data cannot be created, the completion handler will be\
 * called with nil resumeData.\
 */\cf0 \
- (\cf5 void\cf0 )cancelByProducingResumeData:(\cf5 void\cf0  (^)(\cf7 NSData\cf0  * \cf5 _Nullable\cf0  resumeData))completionHandler;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * An NSURLSessionStreamTask provides an interface to perform reads\
 * and writes to a TCP/IP stream created via NSURLSession.  This task\
 * may be explicitly created from an NSURLSession, or created as a\
 * result of the appropriate disposition response to a\
 * -URLSession:dataTask:didReceiveResponse: delegate message.\
 * \
 * NSURLSessionStreamTask can be used to perform asynchronous reads\
 * and writes.  Reads and writes are enquened and executed serially,\
 * with the completion handler being invoked on the sessions delegate\
 * queuee.  If an error occurs, or the task is canceled, all\
 * outstanding read and write calls will have their completion\
 * handlers invoked with an appropriate error.\
 *\
 * It is also possible to create NSInputStream and NSOutputStream\
 * instances from an NSURLSessionTask by sending\
 * -captureStreams to the task.  All outstanding read and writess are\
 * completed before the streams are created.  Once the streams are\
 * delivered to the session delegate, the task is considered complete\
 * and will receive no more messsages.  These streams are\
 * disassociated from the underlying session.\
 */\cf0 \
\
\cf3 NS_CLASS_AVAILABLE\cf0 (\cf6 10\cf0 _11, \cf6 9\cf0 _0)\
\cf5 @interface\cf0  NSURLSessionStreamTask : \cf7 NSURLSessionTask\cf0 \
\
\cf2 /* Read minBytes, or at most maxBytes bytes and invoke the completion\
 * handler on the sessions delegate queue with the data or an error.\
 * If an error occurs, any outstanding reads will also fail, and new\
 * read requests will error out immediately.\
 */\cf0 \
- (\cf5 void\cf0 )readDataOfMinLength:(\cf7 NSUInteger\cf0 )minBytes maxLength:(\cf7 NSUInteger\cf0 )maxBytes timeout:(\cf7 NSTimeInterval\cf0 )timeout completionHandler:(\cf5 void\cf0  (^) (\cf7 NSData\cf0  * \cf5 _Nullable\cf0  data, \cf5 BOOL\cf0  atEOF, \cf7 NSError\cf0  * \cf5 _Nullable\cf0  error))completionHandler;\
\
\cf2 /* Write the data completely to the underlying socket.  If all the\
 * bytes have not been written by the timeout, a timeout error will\
 * occur.  Note that invocation of the completion handler does not\
 * guarantee that the remote side has received all the bytes, only\
 * that they have been written to the kernel. */\cf0 \
- (\cf5 void\cf0 )writeData:(\cf7 NSData\cf0  *)data timeout:(\cf7 NSTimeInterval\cf0 )timeout completionHandler:(\cf5 void\cf0  (^) (\cf7 NSError\cf0  * \cf5 _Nullable\cf0  error))completionHandler;\
\
\cf2 /* -captureStreams completes any already enqueued reads\
 * and writes, and then invokes the\
 * URLSession:streamTask:didBecomeInputStream:outputStream: delegate\
 * message. When that message is received, the task object is\
 * considered completed and will not receive any more delegate\
 * messages. */\cf0 \
- (\cf5 void\cf0 )captureStreams;\
\
\cf2 /* Enqueue a request to close the write end of the underlying socket.\
 * All outstanding IO will complete before the write side of the\
 * socket is closed.  The server, however, may continue to write bytes\
 * back to the client, so best practice is to continue reading from\
 * the server until you receive EOF.\
 */\cf0 \
- (\cf5 void\cf0 )closeWrite;\
\
\cf2 /* Enqueue a request to close the read side of the underlying socket.\
 * All outstanding IO will complete before the read side is closed.\
 * You may continue writing to the server.\
 */\cf0 \
- (\cf5 void\cf0 )closeRead;\
\
\cf2 /*\
 * Begin encrypted handshake.  The hanshake begins after all pending \
 * IO has completed.  TLS authentication callbacks are sent to the \
 * session's -URLSession:task:didReceiveChallenge:completionHandler:\
 */\cf0 \
- (\cf5 void\cf0 )startSecureConnection;\
\
\cf2 /*\
 * Cleanly close a secure connection after all pending secure IO has \
 * completed.\
 */\cf0 \
- (\cf5 void\cf0 )stopSecureConnection;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * Configuration options for an NSURLSession.  When a session is\
 * created, a copy of the configuration object is made - you cannot\
 * modify the configuration of a session after it has been created.\
 *\
 * The shared session uses the global singleton credential, cache\
 * and cookie storage objects.\
 *\
 * An ephemeral session has no persistent disk storage for cookies,\
 * cache or credentials.\
 *\
 * A background session can be used to perform networking operations\
 * on behalf of a suspended application, within certain constraints.\
 */\cf0 \
\cf3 NS_CLASS_AVAILABLE\cf0 (\cf3 NSURLSESSION_AVAILABLE\cf0 , \cf6 7\cf0 _0)\
\cf5 @interface\cf0  NSURLSessionConfiguration : \cf7 NSObject\cf0  <\cf7 NSCopying\cf0 >\
\
\cf3 #if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(\cf6 8\cf3 )\
\cf5 @property\cf0  (\cf5 class\cf0 , \cf5 readonly\cf0 , \cf5 strong\cf0 ) \cf7 NSURLSessionConfiguration\cf0  *defaultSessionConfiguration;\
\cf5 @property\cf0  (\cf5 class\cf0 , \cf5 readonly\cf0 , \cf5 strong\cf0 ) \cf7 NSURLSessionConfiguration\cf0  *ephemeralSessionConfiguration;\
\cf3 #endif\
\cf0 \
+ (\cf7 NSURLSessionConfiguration\cf0  *)backgroundSessionConfigurationWithIdentifier:(\cf7 NSString\cf0  *)identifier \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\
\cf2 /* identifier for the background session configuration */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 readonly\cf0 , \cf5 copy\cf0 ) \cf7 NSString\cf0  *identifier;\
\
\cf2 /* default cache policy for requests */\cf0 \
\cf5 @property\cf0  \cf7 NSURLRequestCachePolicy\cf0  requestCachePolicy;\
\
\cf2 /* default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted. */\cf0 \
\cf5 @property\cf0  \cf7 NSTimeInterval\cf0  timeoutIntervalForRequest;\
\
\cf2 /* default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout. */\cf0 \
\cf5 @property\cf0  \cf7 NSTimeInterval\cf0  timeoutIntervalForResource;\
\
\cf2 /* type of service for requests. */\cf0 \
\cf5 @property\cf0  \cf7 NSURLRequestNetworkServiceType\cf0  networkServiceType;\
\
\cf2 /* allow request to route over cellular. */\cf0 \
\cf5 @property\cf0  \cf5 BOOL\cf0  allowsCellularAccess;\
\
\cf2 /* allows background tasks to be scheduled at the discretion of the system for optimal performance. */\cf0 \
\cf5 @property\cf0  (\cf5 getter\cf0 =isDiscretionary) \cf5 BOOL\cf0  discretionary \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 7\cf0 _0);\
\
\cf2 /* The identifier of the shared data container into which files in background sessions should be downloaded.\
 * App extensions wishing to use background sessions *must* set this property to a valid container identifier, or\
 * all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) \cf7 NSString\cf0  *sharedContainerIdentifier \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _10, \cf6 8\cf0 _0);\
\
\cf2 /* \
 * Allows the app to be resumed or launched in the background when tasks in background sessions complete\
 * or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:\
 * and the default value is YES.\
 */\cf0 \
\cf5 @property\cf0  \cf5 BOOL\cf0  sessionSendsLaunchEvents \cf3 NS_AVAILABLE\cf0 (NA, \cf6 7\cf0 _0);\
\
\cf2 /* The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h> */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) \cf7 NSDictionary\cf0  *connectionProxyDictionary;\
\
\cf2 /* The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h> */\cf0 \
\cf5 @property\cf0  \cf7 SSLProtocol\cf0  TLSMinimumSupportedProtocol;\
\
\cf2 /* The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h> */\cf0 \
\cf5 @property\cf0  \cf7 SSLProtocol\cf0  TLSMaximumSupportedProtocol;\
\
\cf2 /* Allow the use of HTTP pipelining */\cf0 \
\cf5 @property\cf0  \cf5 BOOL\cf0  HTTPShouldUsePipelining;\
\
\cf2 /* Allow the session to set cookies on requests */\cf0 \
\cf5 @property\cf0  \cf5 BOOL\cf0  HTTPShouldSetCookies;\
\
\cf2 /* Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage. */\cf0 \
\cf5 @property\cf0  \cf7 NSHTTPCookieAcceptPolicy\cf0  HTTPCookieAcceptPolicy;\
\
\cf2 /* Specifies additional headers which will be set on outgoing requests.\
   Note that these headers are added to the request only if not already present. */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) \cf7 NSDictionary\cf0  *HTTPAdditionalHeaders;\
\
\cf2 /* The maximum number of simultanous persistent connections per host */\cf0 \
\cf5 @property\cf0  \cf7 NSInteger\cf0  HTTPMaximumConnectionsPerHost;\
\
\cf2 /* The cookie storage object to use, or nil to indicate that no cookies should be handled */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 retain\cf0 ) \cf7 NSHTTPCookieStorage\cf0  *HTTPCookieStorage;\
\
\cf2 /* The credential storage object, or nil to indicate that no credential storage is to be used */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 retain\cf0 ) \cf7 NSURLCredentialStorage\cf0  *URLCredentialStorage;\
\
\cf2 /* The URL resource cache, or nil to indicate that no caching is to be performed */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 retain\cf0 ) \cf7 NSURLCache\cf0  *URLCache;\
\
\cf2 /* Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open\
 *  and delay reclaiming it when the process moves to the background (see {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/library/ios/technotes/tn2277/_index.html)"}}{\fldrslt \cf8 https://developer.apple.com/library/ios/technotes/tn2277/_index.html)}} \
 */\cf0 \
\cf5 @property\cf0  \cf5 BOOL\cf0  shouldUseExtendedBackgroundIdleMode \cf3 NS_AVAILABLE\cf0 (\cf6 10\cf0 _11, \cf6 9\cf0 _0);\
\
\cf2 /* An optional array of Class objects which subclass NSURLProtocol.\
   The Class will be sent +canInitWithRequest: when determining if\
   an instance of the class can be used for a given URL scheme.\
   You should not use +[NSURLProtocol registerClass:], as that\
   method will register your class with the default session rather\
   than with an instance of NSURLSession. \
   Custom NSURLProtocol subclasses are not available to background\
   sessions.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 ) \cf7 NSArray\cf0 <Class> *protocolClasses;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * Disposition options for various delegate messages\
 */\cf0 \
\cf5 typedef\cf0  \cf5 NS_ENUM\cf0 (NSInteger, NSURLSessionAuthChallengeDisposition) \{\
    NSURLSessionAuthChallengeUseCredential = \cf6 0\cf0 ,                                       \cf2 /* Use the specified credential, which may be nil */\cf0 \
    NSURLSessionAuthChallengePerformDefaultHandling = \cf6 1\cf0 ,                              \cf2 /* Default handling for the challenge - as if this delegate were not implemented; the credential parameter is ignored. */\cf0 \
    NSURLSessionAuthChallengeCancelAuthenticationChallenge = \cf6 2\cf0 ,                       \cf2 /* The entire request will be canceled; the credential parameter is ignored. */\cf0 \
    NSURLSessionAuthChallengeRejectProtectionSpace = \cf6 3\cf0 ,                               \cf2 /* This challenge is rejected and the next authentication protection space should be tried; the credential parameter is ignored. */\cf0 \
\} \cf3 NS_ENUM_AVAILABLE\cf0 (\cf3 NSURLSESSION_AVAILABLE\cf0 , \cf6 7\cf0 _0);\
\
\
\cf5 typedef\cf0  \cf5 NS_ENUM\cf0 (NSInteger, NSURLSessionResponseDisposition) \{\
    NSURLSessionResponseCancel = \cf6 0\cf0 ,                                      \cf2 /* Cancel the load, this is the same as -[task cancel] */\cf0 \
    NSURLSessionResponseAllow = \cf6 1\cf0 ,                                       \cf2 /* Allow the load to continue */\cf0 \
    NSURLSessionResponseBecomeDownload = \cf6 2\cf0 ,                              \cf2 /* Turn this request into a download */\cf0 \
    NSURLSessionResponseBecomeStream \cf3 NS_ENUM_AVAILABLE\cf0 (\cf6 10\cf0 _11, \cf6 9\cf0 _0) = \cf6 3\cf0 ,  \cf2 /* Turn this task into a stream task */\cf0 \
\} \cf3 NS_ENUM_AVAILABLE\cf0 (\cf3 NSURLSESSION_AVAILABLE\cf0 , \cf6 7\cf0 _0);\
\
\cf2 /*\
 * NSURLSessionDelegate specifies the methods that a session delegate\
 * may respond to.  There are both session specific messages (for\
 * example, connection based auth) as well as task based messages.\
 */\cf0 \
\
\cf2 /*\
 * Messages related to the URL session as a whole\
 */\cf0 \
\cf5 @protocol\cf0  NSURLSessionDelegate <\cf7 NSObject\cf0 >\
\cf5 @optional\cf0 \
\
\cf2 /* The last message a session receives.  A session will only become\
 * invalid because of a systemic error or when it has been\
 * explicitly invalidated, in which case the error parameter will be nil.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session didBecomeInvalidWithError:(\cf5 nullable\cf0  \cf7 NSError\cf0  *)error;\
\
\cf2 /* If implemented, when a connection level authentication challenge\
 * has occurred, this delegate will be given the opportunity to\
 * provide authentication credentials to the underlying\
 * connection. Some types of authentication will apply to more than\
 * one request on a given connection to a server (SSL Server Trust\
 * challenges).  If this delegate message is not implemented, the \
 * behavior will be to use the default handling, which may involve user\
 * interaction. \
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session didReceiveChallenge:(\cf7 NSURLAuthenticationChallenge\cf0  *)challenge\
                                             completionHandler:(\cf5 void\cf0  (^)(\cf7 NSURLSessionAuthChallengeDisposition\cf0  disposition, \cf7 NSURLCredential\cf0  * \cf5 _Nullable\cf0  credential))completionHandler;\
\
\cf2 /* If an application has received an\
 * -application:handleEventsForBackgroundURLSession:completionHandler:\
 * message, the session delegate will receive this message to indicate\
 * that all messages previously enqueued for this session have been\
 * delivered.  At this time it is safe to invoke the previously stored\
 * completion handler, or to begin any internal updates that will\
 * result in invoking the completion handler.\
 */\cf0 \
- (\cf5 void\cf0 )URLSessionDidFinishEventsForBackgroundURLSession:(\cf7 NSURLSession\cf0  *)session \cf3 NS_AVAILABLE_IOS\cf0 (\cf6 7\cf0 _0);\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * Messages related to the operation of a specific task.\
 */\cf0 \
\cf5 @protocol\cf0  NSURLSessionTaskDelegate <\cf7 NSURLSessionDelegate\cf0 >\
\cf5 @optional\cf0 \
\
\cf2 /* An HTTP request is attempting to perform a redirection to a different\
 * URL. You must invoke the completion routine to allow the\
 * redirection, allow the redirection with a modified request, or\
 * pass nil to the completionHandler to cause the body of the redirection \
 * response to be delivered as the payload of this request. The default\
 * is to follow redirections. \
 *\
 * For tasks in background sessions, redirections will always be followed and this method will not be called.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task\
                     willPerformHTTPRedirection:(\cf7 NSHTTPURLResponse\cf0  *)response\
                                     newRequest:(\cf7 NSURLRequest\cf0  *)request\
                              completionHandler:(\cf5 void\cf0  (^)(\cf7 NSURLRequest\cf0  * \cf5 _Nullable\cf0 ))completionHandler;\
\
\cf2 /* The task has received a request specific authentication challenge.\
 * If this delegate is not implemented, the session specific authentication challenge\
 * will *NOT* be called and the behavior will be the same as using the default handling\
 * disposition. \
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task\
                            didReceiveChallenge:(\cf7 NSURLAuthenticationChallenge\cf0  *)challenge \
                              completionHandler:(\cf5 void\cf0  (^)(\cf7 NSURLSessionAuthChallengeDisposition\cf0  disposition, \cf7 NSURLCredential\cf0  * \cf5 _Nullable\cf0  credential))completionHandler;\
\
\cf2 /* Sent if a task requires a new, unopened body stream.  This may be\
 * necessary when authentication has failed for any request that\
 * involves a body stream. \
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task\
                              needNewBodyStream:(\cf5 void\cf0  (^)(\cf7 NSInputStream\cf0  * \cf5 _Nullable\cf0  bodyStream))completionHandler;\
\
\cf2 /* Sent periodically to notify the delegate of upload progress.  This\
 * information is also available as properties of the task.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task\
                                didSendBodyData:(\cf7 int64_t\cf0 )bytesSent\
                                 totalBytesSent:(\cf7 int64_t\cf0 )totalBytesSent\
                       totalBytesExpectedToSend:(\cf7 int64_t\cf0 )totalBytesExpectedToSend;\
\
\cf2 /*\
 * Sent when complete statistics information has been collected for the task.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task didFinishCollectingMetrics:(\cf7 NSURLSessionTaskMetrics\cf0  *)metrics \cf3 API_AVAILABLE\cf0 (macosx(\cf6 10.12\cf0 ), ios(\cf6 10.0\cf0 ), watchos(\cf6 3.0\cf0 ), tvos(\cf6 10.0\cf0 ));\
\
\cf2 /* Sent as the last message related to a specific task.  Error may be\
 * nil, which implies that no error occurred and this task is complete. \
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session task:(\cf7 NSURLSessionTask\cf0  *)task\
                           didCompleteWithError:(\cf5 nullable\cf0  \cf7 NSError\cf0  *)error;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * Messages related to the operation of a task that delivers data\
 * directly to the delegate.\
 */\cf0 \
\cf5 @protocol\cf0  NSURLSessionDataDelegate <\cf7 NSURLSessionTaskDelegate\cf0 >\
\cf5 @optional\cf0 \
\cf2 /* The task has received a response and no further messages will be\
 * received until the completion block is called. The disposition\
 * allows you to cancel a request or to turn a data task into a\
 * download task. This delegate message is optional - if you do not\
 * implement it, you can get the response as a property of the task.\
 *\
 * This method will not be called for background upload tasks (which cannot be converted to download tasks).\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session dataTask:(\cf7 NSURLSessionDataTask\cf0  *)dataTask\
                                 didReceiveResponse:(\cf7 NSURLResponse\cf0  *)response\
                                  completionHandler:(\cf5 void\cf0  (^)(\cf7 NSURLSessionResponseDisposition\cf0  disposition))completionHandler;\
\
\cf2 /* Notification that a data task has become a download task.  No\
 * future messages will be sent to the data task.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session dataTask:(\cf7 NSURLSessionDataTask\cf0  *)dataTask\
                              didBecomeDownloadTask:(\cf7 NSURLSessionDownloadTask\cf0  *)downloadTask;\
\
\cf2 /*\
 * Notification that a data task has become a bidirectional stream\
 * task.  No future messages will be sent to the data task.  The newly\
 * created streamTask will carry the original request and response as\
 * properties.\
 *\
 * For requests that were pipelined, the stream object will only allow\
 * reading, and the object will immediately issue a\
 * -URLSession:writeClosedForStream:.  Pipelining can be disabled for\
 * all requests in a session, or by the NSURLRequest\
 * HTTPShouldUsePipelining property.\
 *\
 * The underlying connection is no longer considered part of the HTTP\
 * connection cache and won't count against the total number of\
 * connections per host.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session dataTask:(\cf7 NSURLSessionDataTask\cf0  *)dataTask\
                                didBecomeStreamTask:(\cf7 NSURLSessionStreamTask\cf0  *)streamTask;\
\
\cf2 /* Sent when data is available for the delegate to consume.  It is\
 * assumed that the delegate will retain and not copy the data.  As\
 * the data may be discontiguous, you should use \
 * [NSData enumerateByteRangesUsingBlock:] to access it.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session dataTask:(\cf7 NSURLSessionDataTask\cf0  *)dataTask\
                                     didReceiveData:(\cf7 NSData\cf0  *)data;\
\
\cf2 /* Invoke the completion routine with a valid NSCachedURLResponse to\
 * allow the resulting data to be cached, or pass nil to prevent\
 * caching. Note that there is no guarantee that caching will be\
 * attempted for a given resource, and you should not rely on this\
 * message to receive the resource data.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session dataTask:(\cf7 NSURLSessionDataTask\cf0  *)dataTask\
                                  willCacheResponse:(\cf7 NSCachedURLResponse\cf0  *)proposedResponse \
                                  completionHandler:(\cf5 void\cf0  (^)(\cf7 NSCachedURLResponse\cf0  * \cf5 _Nullable\cf0  cachedResponse))completionHandler;\
\
\cf5 @end\cf0 \
\
\cf2 /*\
 * Messages related to the operation of a task that writes data to a\
 * file and notifies the delegate upon completion.\
 */\cf0 \
\cf5 @protocol\cf0  NSURLSessionDownloadDelegate <\cf7 NSURLSessionTaskDelegate\cf0 >\
\
\cf2 /* Sent when a download task that has completed a download.  The delegate should \
 * copy or move the file at the given location to a new location as it will be \
 * removed when the delegate message returns. URLSession:task:didCompleteWithError: will\
 * still be called.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session downloadTask:(\cf7 NSURLSessionDownloadTask\cf0  *)downloadTask\
                              didFinishDownloadingToURL:(\cf7 NSURL\cf0  *)location;\
\
\cf5 @optional\cf0 \
\cf2 /* Sent periodically to notify the delegate of download progress. */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session downloadTask:(\cf7 NSURLSessionDownloadTask\cf0  *)downloadTask\
                                           didWriteData:(\cf7 int64_t\cf0 )bytesWritten\
                                      totalBytesWritten:(\cf7 int64_t\cf0 )totalBytesWritten\
                              totalBytesExpectedToWrite:(\cf7 int64_t\cf0 )totalBytesExpectedToWrite;\
\
\cf2 /* Sent when a download has been resumed. If a download failed with an\
 * error, the -userInfo dictionary of the error will contain an\
 * NSURLSessionDownloadTaskResumeData key, whose value is the resume\
 * data. \
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session downloadTask:(\cf7 NSURLSessionDownloadTask\cf0  *)downloadTask\
                                      didResumeAtOffset:(\cf7 int64_t\cf0 )fileOffset\
                                     expectedTotalBytes:(\cf7 int64_t\cf0 )expectedTotalBytes;\
\
\cf5 @end\cf0 \
\
\cf5 @protocol\cf0  NSURLSessionStreamDelegate <\cf7 NSURLSessionTaskDelegate\cf0 >\
\cf5 @optional\cf0 \
\
\cf2 /* \
\

\f1   \'b1\'ed\'ca\'be\'c1\'ac\'bd\'d3\'b5\'c4\'b6\'c1\'c8\'a1\'b6\'cb\'d2\'d1\'b9\'d8\'b1\'d5.
\f0 \
 
\f1 \'c8\'ce\'ba\'ce\'ce\'b4\'cd\'ea\'b3\'c9\'b5\'c4\'b6\'c1\'c8\'a1\'cd\'ea\'b3\'c9\'a3\'ac\'b5\'ab\'ce\'b4\'c0\'b4\'b5\'c4\'b6\'c1\'c8\'a1\'bd\'ab\'c1\'a2\'bc\'b4\'ca\'a7\'b0\'dc.
\f0 \
 
\f1 \'bc\'b4\'ca\'b9\'c3\'bb\'d3\'d0\'d5\'fd\'d4\'da\'bd\'f8\'d0\'d0\'b6\'c1\'c8\'a1\'a3\'ac\'d2\'b2\'bf\'c9\'c4\'dc\'bb\'e1\'b7\'a2\'cb\'cd\'b4\'cb\'cf\'fb\'cf\'a2
\f0 \
 
\f1 \'b5\'ab\'ca\'c7\'a3\'ac\'b5\'b1\'bd\'d3\'ca\'d5\'b5\'bd\'b4\'cb\'ce\'af\'c5\'c9\'cf\'fb\'cf\'a2\'ca\'b1\'a3\'ac\'c8\'d4\'bf\'c9\'c4\'dc\'d3\'d0\'d7\'d6\'bd\'da\'bf\'c9\'d3\'c3\'a1\'a3
\f0  \
 
\f1 \'c4\'e3\'d6\'bb\'d6\'aa\'b5\'c0\'b5\'b1\'c4\'e3\'c4\'dc\'b6\'c1\'b5\'bd
\f0 EOF
\f1 \'ca\'b1\'a3\'ac\'c3\'bb\'d3\'d0\'b8\'fc\'b6\'e0\'b5\'c4\'d7\'d6\'bd\'da\'bf\'c9\'d3\'c3\'a1\'a3
\f0 \
\
*/\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session readClosedForStreamTask:(\cf7 NSURLSessionStreamTask\cf0  *)streamTask;\
\
\cf2 /* Indiciates that the write side of a connection has been closed.\
 * Any outstanding writes complete, but future writes will immediately\
 * fail.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session writeClosedForStreamTask:(\cf7 NSURLSessionStreamTask\cf0  *)streamTask;\
\
\cf2 /* A notification that the system has determined that a better route\
 * to the host has been detected (eg, a wi-fi interface becoming\
 * available.)  This is a hint to the delegate that it may be\
 * desirable to create a new task for subsequent work.  Note that\
 * there is no guarantee that the future task will be able to connect\
 * to the host, so callers should should be prepared for failure of\
 * reads and writes over any new interface. */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session betterRouteDiscoveredForStreamTask:(\cf7 NSURLSessionStreamTask\cf0  *)streamTask;\
\
\cf2 /* The given task has been completed, and unopened NSInputStream and\
 * NSOutputStream objects are created from the underlying network\
 * connection.  This will only be invoked after all enqueued IO has\
 * completed (including any necessary handshakes.)  The streamTask\
 * will not receive any further delegate messages.\
 */\cf0 \
- (\cf5 void\cf0 )URLSession:(\cf7 NSURLSession\cf0  *)session streamTask:(\cf7 NSURLSessionStreamTask\cf0  *)streamTask\
                                 didBecomeInputStream:(\cf7 NSInputStream\cf0  *)inputStream\
                                         outputStream:(\cf7 NSOutputStream\cf0  *)outputStream;\
\
\cf5 @end\cf0 \
\
\cf2 /* Key in the userInfo dictionary of an NSError received during a failed download. */\cf0 \
\cf3 FOUNDATION_EXPORT\cf0  \cf7 NSString\cf0  * \cf5 const\cf0  NSURLSessionDownloadTaskResumeData \cf3 NS_AVAILABLE\cf0 (\cf3 NSURLSESSION_AVAILABLE\cf0 , \cf6 7\cf0 _0);\
\
\cf5 @interface\cf0  NSURLSessionConfiguration (NSURLSessionDeprecated)\
+ (\cf7 NSURLSessionConfiguration\cf0  *)backgroundSessionConfiguration:(\cf7 NSString\cf0  *)identifier \cf3 NS_DEPRECATED\cf0 (\cf3 NSURLSESSION_AVAILABLE\cf0 , \cf6 10\cf0 _10, \cf6 7\cf0 _0, \cf6 8\cf0 _0, \cf4 "Please use backgroundSessionConfigurationWithIdentifier: instead"\cf0 );\
\cf5 @end\cf0 \
\
\cf2 /*\
 * The resource fetch type.\
 */\cf0 \
\cf5 typedef\cf0  \cf5 NS_ENUM\cf0 (NSInteger, NSURLSessionTaskMetricsResourceFetchType) \{\
    NSURLSessionTaskMetricsResourceFetchTypeUnknown,\
    NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad,   \cf2 /* The resource was loaded over the network. */\cf0 \
    NSURLSessionTaskMetricsResourceFetchTypeServerPush,    \cf2 /* The resource was pushed by the server to the client. */\cf0 \
    NSURLSessionTaskMetricsResourceFetchTypeLocalCache,    \cf2 /* The resource was retrieved from the local storage. */\cf0 \
\} \cf3 API_AVAILABLE\cf0 (macosx(\cf6 10.12\cf0 ), ios(\cf6 10.0\cf0 ), watchos(\cf6 3.0\cf0 ), tvos(\cf6 10.0\cf0 ));\
\
\cf2 /*\
 * This class defines the performance metrics collected for a request/response transaction during the task execution.\
 */\cf0 \
\cf3 API_AVAILABLE\cf0 (macosx(\cf6 10.12\cf0 ), ios(\cf6 10.0\cf0 ), watchos(\cf6 3.0\cf0 ), tvos(\cf6 10.0\cf0 ))\
\cf5 @interface\cf0  NSURLSessionTaskTransactionMetrics : \cf7 NSObject\cf0 \
\
\cf2 /*\
 * Represents the transaction request.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSURLRequest\cf0  *request;\
\
\cf2 /*\
 * Represents the transaction response. Can be nil if error occurred and no response was generated.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSURLResponse\cf0  *response;\
\
\cf2 /*\
 * For all NSDate metrics below, if that aspect of the task could not be completed, then the corresponding \'93EndDate\'94 metric will be nil.\
 * For example, if a name lookup was started but the name lookup timed out, failed, or the client canceled the task before the name could be resolved -- then while domainLookupStartDate may be set, domainLookupEndDate will be nil along with all later metrics.\
 */\cf0 \
\
\cf2 /*\
 * fetchStartDate returns the time when the user agent started fetching the resource, whether or not the resource was retrieved from the server or local resources.\
 *\
 * The following metrics will be set to nil, if a persistent connection was used or the resource was retrieved from local resources:\
 *\
 *   domainLookupStartDate\
 *   domainLookupEndDate\
 *   connectStartDate\
 *   connectEndDate\
 *   secureConnectionStartDate\
 *   secureConnectionEndDate\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *fetchStartDate;\
\
\cf2 /*\
 * domainLookupStartDate returns the time immediately before the user agent started the name lookup for the resource.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *domainLookupStartDate;\
\
\cf2 /*\
 * domainLookupEndDate returns the time after the name lookup was completed.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *domainLookupEndDate;\
\
\cf2 /*\
 * connectStartDate is the time immediately before the user agent started establishing the connection to the server.\
 *\
 * For example, this would correspond to the time immediately before the user agent started trying to establish the TCP connection.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *connectStartDate;\
\
\cf2 /*\
 * If an encrypted connection was used, secureConnectionStartDate is the time immediately before the user agent started the security handshake to secure the current connection.\
 *\
 * For example, this would correspond to the time immediately before the user agent started the TLS handshake.\
 *\
 * If an encrypted connection was not used, this attribute is set to nil.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *secureConnectionStartDate;\
\
\cf2 /*\
 * If an encrypted connection was used, secureConnectionEndDate is the time immediately after the security handshake completed.\
 *\
 * If an encrypted connection was not used, this attribute is set to nil.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *secureConnectionEndDate;\
\
\cf2 /*\
 * connectEndDate is the time immediately after the user agent finished establishing the connection to the server, including completion of security-related and other handshakes.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *connectEndDate;\
\
\cf2 /*\
 * requestStartDate is the time immediately before the user agent started requesting the source, regardless of whether the resource was retrieved from the server or local resources.\
 *\
 * For example, this would correspond to the time immediately before the user agent sent an HTTP GET request.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *requestStartDate;\
\
\cf2 /*\
 * requestEndDate is the time immediately after the user agent finished requesting the source, regardless of whether the resource was retrieved from the server or local resources.\
 *\
 * For example, this would correspond to the time immediately after the user agent finished sending the last byte of the request.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *requestEndDate;\
\
\cf2 /*\
 * responseStartDate is the time immediately after the user agent received the first byte of the response from the server or from local resources.\
 *\
 * For example, this would correspond to the time immediately after the user agent received the first byte of an HTTP response.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *responseStartDate;\
\
\cf2 /*\
 * responseEndDate is the time immediately after the user agent received the last byte of the resource.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDate\cf0  *responseEndDate;\
\
\cf2 /*\
 * The network protocol used to fetch the resource, as identified by the ALPN Protocol ID Identification Sequence [RFC7301].\
 * E.g., h2, http/1.1, spdy/3.1.\
 *\
 * When a proxy is configured AND a tunnel connection is established, then this attribute returns the value for the tunneled protocol.\
 *\
 * For example:\
 * If no proxy were used, and HTTP/2 was negotiated, then h2 would be returned.\
 * If HTTP/1.1 were used to the proxy, and the tunneled connection was HTTP/2, then h2 would be returned.\
 * If HTTP/1.1 were used to the proxy, and there were no tunnel, then http/1.1 would be returned.\
 *\
 */\cf0 \
\cf5 @property\cf0  (\cf5 nullable\cf0 , \cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSString\cf0  *networkProtocolName;\
\
\cf2 /*\
 * This property is set to YES if a proxy connection was used to fetch the resource.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 assign\cf0 , \cf5 readonly\cf0 , \cf5 getter\cf0 =isProxyConnection) \cf5 BOOL\cf0  proxyConnection;\
\
\cf2 /*\
 * This property is set to YES if a persistent connection was used to fetch the resource.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 assign\cf0 , \cf5 readonly\cf0 , \cf5 getter\cf0 =isReusedConnection) \cf5 BOOL\cf0  reusedConnection;\
\
\cf2 /*\
 * Indicates whether the resource was loaded, pushed or retrieved from the local cache.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 assign\cf0 , \cf5 readonly\cf0 ) \cf7 NSURLSessionTaskMetricsResourceFetchType\cf0  resourceFetchType;\
\
\
-(\cf5 instancetype\cf0 )init;\
\
\
\cf5 @end\cf0 \
\
\
\cf3 API_AVAILABLE\cf0 (macosx(\cf6 10.12\cf0 ), ios(\cf6 10.0\cf0 ), watchos(\cf6 3.0\cf0 ), tvos(\cf6 10.0\cf0 ))\
\cf5 @interface\cf0  NSURLSessionTaskMetrics : \cf7 NSObject\cf0 \
\
\cf2 /*\
 * transactionMetrics array contains the metrics collected for every request/response transaction created during the task execution.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSArray\cf0 <\cf7 NSURLSessionTaskTransactionMetrics\cf0  *> *transactionMetrics;\
\
\cf2 /*\
 * Interval from the task creation time to the task completion time.\
 * Task creation time is the time when the task was instantiated.\
 * Task completion time is the time when the task is about to change its internal state to completed.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 copy\cf0 , \cf5 readonly\cf0 ) \cf7 NSDateInterval\cf0  *taskInterval;\
\
\cf2 /*\
 * redirectCount is the number of redirects that were recorded.\
 */\cf0 \
\cf5 @property\cf0  (\cf5 assign\cf0 , \cf5 readonly\cf0 ) \cf7 NSUInteger\cf0  redirectCount;\
\
-(\cf5 instancetype\cf0 )init;\
\
\cf5 @end\cf0 \
\
\cf3 NS_ASSUME_NONNULL_END\cf0 \
}